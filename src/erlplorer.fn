
fn main @public
  case ["info" :: Paths]:
    Result = lists.map(Paths) <<- case Path:
      handle_file(Path)
    end

    print_and_exit(Result)
  case Args:
    io.format("Unknown Arguments: ~p~n", [Args])
    usage()
    erlang.halt(0)
end

fn usage case:
  io.format("USAGE: erlplorer info <file>+~n")
end

fn parse_file case Path:
  match lists.reverse(Path):
    case "lre." ++ _:
      ParseResult = epp.parse_file(Path, [], [])
    case "nf." ++ _:
      efene.to_mod(Path)
    else:
      (error, (invalid_file, Path))
  end
end

fn fun_part_to_name
  case (atom, _, Name): atom_to_list(Name)
  case (var, _, _Name): "_"
end

fn fun_to_name case Mod, Fun, Args:
  ModName = fun_part_to_name(Mod)
  FunName = fun_part_to_name(Fun)
  Arity = length(Args)
  list_to_binary(io_lib.format("~s:~s/~p", [ModName, FunName, Arity]))
end

fn analyze_path @public case Path:
  match parse_file(Path):
    case ok, Ast:
      Walker = fn
        case State, Node=(call, Line, (remote, _La, Mod, Fun), Args):
          MFA = fun_to_name(Mod, Fun, Args)
          State1 = inc(State, external_funs, MFA)
          match Mod:
            case (atom, _, ModName):
              (Node, inc(State1, modules, ModName))
            else:
              (Node, State1)
          end
        case State={functions=Funs}, Node=(function, Line, Name, Arity, Clauses):
          (clause, _, _, _, Forms) = lists.last(Clauses)
          LastForm = lists.last(Forms)
          LastLine = element(2, LastForm)
          ClausesInfo = analyze_clauses(Node)
          Info = maps.merge({line: Line,
                             name: Name,
                             length: LastLine - Line + 1,
                             arity: Arity,
                             clauses: length(Clauses)},
                            ClausesInfo)
          FunA = io_lib.format("~s/~p", [Name, Arity]) -> list_to_binary()
          Funs1 = maps.put(FunA, Info, Funs)
          State1 = maps.put(functions, Funs1, State)
          (Node, State1)
        case State, Node:
          (Node, State)
      end

      State0 = {modules: {}, external_funs: {}, functions: {}}
      (_, Stats) = erl_ast_walk.walk(Ast, Walker, State0)

      (ok, Stats)
    case error, Reason:
      (error, {reason: (io_lib.format("~p", [Reason]) -> list_to_binary())})
  end
end

fn add_item_line case Key, Map, Name, Line:
  Items = maps.get(Key, Map, {})
  Lines = maps.get(Name, Items, [])
  NewLines = [Line :: Lines]
  NewItems = maps.put(Name, NewLines, Items)
  maps.put(Key, NewItems, Map)
end

fn analyze_clauses case Ast:
  Walker = fn
    case State, Node=(var, Line, Name):
      State1 = add_item_line(vars, State, Name, Line)
      (Node, State1)
    case State, Node=(call, Line, (remote, _La, Mod, Fun), Args):
      Name = fun_to_name(Mod, Fun, Args)
      State1 = add_item_line(remote_calls, State, Name, Line)
      (Node, State1)
    case State, Node=(call, Line, (atom, _La, Fun), Args):
      Arity = length(Args)
      Name = list_to_binary(io_lib.format("~p/~p", [Fun, Arity]))
      State1 = add_item_line(calls, State, Name, Line)
      (Node, State1)

    case State, Node=(record_index, Line, Name, _Field):
      State1 = add_item_line(records, State, Name, Line)
      (Node, State1)
    case State, Node=(record_field, Line, _Rec, Name, _Field):
      State1 = add_item_line(records, State, Name, Line)
      (Node, State1)
    case State, Node=(record, Line, Name, _Inits):
      State1 = add_item_line(records, State, Name, Line)
      (Node, State1)

    case State, Node=(`if`, _Line, Clauses):
      (Node, inc_key(State, inner_clauses, length(Clauses)))
    case State, Node=(`case`, _Line, _Expr, Clauses):
      (Node, inc_key(State, inner_clauses, length(Clauses)))
    case State, Node=(`receive`, _Line, Clauses):
      (Node, inc_key(State, inner_clauses, length(Clauses)))
    case State, Node=(`receive`, _Line, _Cs, _To, Clauses):
      (Node, inc_key(State, inner_clauses, length(Clauses)))
    case State, Node=(`fun`, _Line, (clauses, Clauses)):
      (Node, inc_key(State, inner_clauses, length(Clauses)))
    case State, Node=(named_fun, _Line, _Name, Clauses):
      (Node, inc_key(State, inner_clauses, length(Clauses)))
    case State, Node=(`try`, _Line, _Es, Scs, Ccs, _As):
      (Node, inc_key(State, inner_clauses, length(Scs) + length(Ccs)))

    case State, Node:
      (Node, State)
  end

  State0 = {vars: {}, remote_calls: {}, calls: {}, records: {},
            inner_clauses: 0}
  (_, Stats) = erl_ast_walk.walk([Ast], Walker, State0)

  Stats
end

fn inc_key case Map, Key, Value:
  CurrentCount = maps.get(Key, Map, 0)
  maps.put(Key, CurrentCount + Value, Map)
end

fn inc case Map, Key, SubKey:
  M1 = maps.get(Key, Map, {})
  CurrentCount = maps.get(SubKey, M1, 0)
  M2 = maps.put(SubKey, CurrentCount + 1, M1)
  maps.put(Key, M2, Map)
end

fn print_and_exit case Data:
  Out = jsx.encode(Data)
  io.format("~s~n", [Out])
  erlang.halt(0)
end

fn handle_file case Path:
  ModuleName = remove_extension(filename.basename(Path)) -> list_to_binary()
  match analyze_path(Path):
    case ok, Result:
       {status: ok, module: ModuleName, data: Result}
    case error, Reason:
       {status: error, reason: Reason, module: ModuleName}
  end
end

fn remove_extension case Name:
  match lists.reverse(Name):
    case "lre." ++ Name1:
      lists.reverse(Name1)
    case "nf." ++ Name1:
      lists.reverse(Name1)
    else:
      Name
  end
end
