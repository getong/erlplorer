
fn main @public
  case ["info" :: Paths]:
    Result = lists.map(Paths) <<- case Path:
      handle_file(Path)
    end

    print_and_exit(Result)
  case Args:
    io.format("Unknown Arguments: ~p~n", [Args])
    usage()
    erlang.halt(0)
end

fn usage case:
  io.format("USAGE: erlplorer info <file>+~n")
end

fn parse_file case Path:
  match lists.reverse(Path):
    case "lre." ++ _:
      ParseResult = epp.parse_file(Path, [], [])
    case "nf." ++ _:
      efene.to_mod(Path)
    else:
      (error, (invalid_file, Path))
  end
end

fn analyze_path @public case Path:
  match parse_file(Path):
    case ok, Ast:
      Walker = fn
        case State, Node=(call, Line, (remote, _La, (atom, _, Mod),
                                       (atom, _, Fun)), Args):
          Arity = length(Args)
          MFA = list_to_binary(io_lib.format("~p:~p/~p", [Mod, Fun, Arity]))

          State1 = inc(State, external_funs, MFA)
          State2 = inc(State1, modules, Mod)

          (Node, State2)
        case State={functions=Funs}, Node=(function, Line, Name, Arity, Clauses):
          (clause, _, _, _, Forms) = lists.last(Clauses)
          LastForm = lists.last(Forms)
          LastLine = element(2, LastForm)
          Info = {line: Line, name: Name, length: LastLine - Line + 1,
                  arity: Arity, clauses: length(Clauses)}
          FunA = io_lib.format("~s/~p", [Name, Arity]) -> list_to_binary()
          Funs1 = maps.put(FunA, Info, Funs)
          State1 = maps.put(functions, Funs1, State)
          (Node, State1)
        case State, Node:
          (Node, State)
      end

      State0 = {modules: {}, external_funs: {}, functions: {}}
      (_, Stats) = erl_ast_walk.walk(Ast, Walker, State0)

      (ok, Stats)
    case error, Reason:
      (error, {reason: (io_lib.format("~p", [Reason]) -> list_to_binary())})
  end
end

fn inc case Map, Key, SubKey:
  M1 = maps.get(Key, Map, {})
  CurrentCount = maps.get(SubKey, M1, 0)
  M2 = maps.put(SubKey, CurrentCount + 1, M1)
  maps.put(Key, M2, Map)
end

fn print_and_exit case Data:
  Out = jsx.encode(Data)
  io.format("~s~n", [Out])
  erlang.halt(0)
end

fn handle_file case Path:
  ModuleName = remove_extension(filename.basename(Path)) -> list_to_binary()
  match analyze_path(Path):
    case ok, Result:
       {status: ok, module: ModuleName, data: Result}
    case error, Reason:
       {status: error, reason: Reason, module: ModuleName}
  end
end

fn remove_extension case Name:
  match lists.reverse(Name):
    case "lre." ++ Name1:
      lists.reverse(Name1)
    case "nf." ++ Name1:
      lists.reverse(Name1)
    else:
      Name
  end
end
